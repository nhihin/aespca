---
title: "Import Kallisto Data - Dataset 1"
author: "Nhi Hin"
date: "2020-05-10"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

```{r load-packages, include=FALSE}
library(AnnotationHub)
library(dplyr)
library(magrittr)
library(edgeR)
library(limma)
library(sleuth)
library(here)
library(readr)
library(tibble)
library(grid)
library(export)
library(reshape2)

# ggplot2 theme
theme_set(theme_bw())
```

## 0. Introduction

- The aim of this RMarkdown is to import the output *kallisto* 
transcript-level count estimates, summarise these to gene-level, perform 
filtering, and prepare them for differential gene expression analysis 
using *limma*. 


## 1. Kallisto

- **Kallisto** (v0.45.0) was run on Phoenix in single-end mode as follows:

```{r engine='bash', eval=FALSE}
THREADS=16
# Directories
TRIMDATA=/fast/users/a1669135/datasets/mouse_1/2_trimData
OUTPUTDIR=/fast/users/a1669135/datasets/mouse_1/3_quantData/kallisto

# Use local version of kallisto v0.45 as it's not installed on phoenix
kallisto=/data/biohub/local/kallisto_linux-v0.45.0/kallisto

# Kallisto index using the primary mouse cDNA assembly
KALISTOIDX=/data/biorefs/reference_genomes/ensembl-release-98/mus_musculus/kallisto/Mus_musculus.GRCm38.cdna.primary_assembly.idx

# Run Kallisto for each trimmed fastq file
cd $TRIMDATA/fastq
TRIM=`ls ${SLURM_ARRAY_TASK_ID}_*.fastq.gz`

# Because the data is single-end, we need length and standard deviation of the 
# fragment length. As this info is unknown I have just used the kallisto 
# defaults. We also run this with multiple bootstraps to account for 
# technical variation. 
$kallisto quant -t $THREADS --single -b 100 -l 200 -s 20 -i $KALLISTOIDX -o $OUTPUTDIR $TRIM
```


## 2. Import Kallisto Output

- The output directories from running *kallisto* were imported using the 
`catchKallisto` function from *edgeR*. 

```{r, eval=FALSE}
# Get paths to the Results directories on Phoenix generated by Kallisto.
kallistoResults <- file.path("/Volumes/fastdir/datasets/mouse_1",
                             "3_quantData/kallisto") %>% 
  file.path %>%
  list.dirs
kallistoResults <- kallistoResults[-1] 

# Takes a while to run so save out the object. 
importedKallisto <- catchKallisto(kallistoResults) 
importedKallisto %>% saveRDS(here("data", "mouse", "kallisto",
                                   "importedKallisto1.rds"))
```
```{r include=FALSE}
importedKallisto <- readRDS(here("data", "datasets", "mouse", "kallisto",
                                   "importedKallisto1.rds"))
```

- Neaten up the column (sample) names

```{r}
colnames(importedKallisto$counts) %<>% 
  basename %>%
  gsub(x = ., pattern = "[[:digit:]]{1,2}_(S.*)_t", 
       replacement = "\\1")
```


## 3. Load Sample Table

- The sample table was previously prepared using the GEO sample matrix.

```{r}
samples <- readRDS(here("data/datasets/mouse/dge_GSE97113.rds"))$samples
samples %<>% as.data.frame %>%
  mutate(group = paste0(sex, genotype, age, "mth"),
                    name = paste0(group, "_",rep(1:5))) 
```

- However, in order to match the sample names to the *kallisto* output, we 
need to link the ENA and GEO identifiers, as the fastqs were downloaded from 
ENA and not GEO.

```{r}
samples_ena <- read_tsv(here("data", "datasets", "mouse", 
                             "GSE97113_PRJNA380737.txt")) %>%
  dplyr::rename(
    ena_accession = run_accession,
    geo_accession = experiment_alias,
    title = sample_title
  ) %>% dplyr::select(-title) 
```

```{r}
samples %<>% left_join(samples_ena, by = "geo_accession")
```


## 4. Transcript-level counts

- Create matrix of the transcript-level count estimates with new names 
from the samples table:

```{r}
counts_t <- importedKallisto$counts[, samples$ena_accession] %>% 
  set_colnames(samples$name)

# Preview
counts_t %>% as.data.frame %>% 
  rownames_to_column("transcript_id") %>% 
  as_tibble
```

## 5. Gene-Transcript Annotation

- To summarise to gene-level counts, we first need to prepare a `data.frame` 
that maps from Ensembl transcript to gene IDs. 

```{r}
# Search for and load relevant AnnotationHub object:
ah <- AnnotationHub()
ah %>%
  subset(grepl("musculus", species)) %>%
  subset(rdataclass == "EnsDb")
ensDb <- ah[["AH64944"]] # Ensembl 94 EnsDb for Mus musculus

# Get gene and transcript information:
genes <- genes(ensDb)
transcripts <- transcripts(ensDb)

mapTx2Gene <- transcripts %>% 
  as.data.frame %>%
  dplyr::select(tx_id_version, gene_id)

# Preview
mapTx2Gene %>% 
  rownames_to_column("transcript_id")%>%
  as_tibble()
```

## 6. Gene-level counts

- Now we can summarise the transcript-level count estimates to gene-level 
count estimates by summing together the transcript-level counts corresponding 
to the same gene. We will also use the new names from the `samples` table. 

```{r}
counts_g <- counts_t %>%
  melt %>% 
  set_colnames(c("tx_id_version", "sample", "count")) %>% 
  left_join(mapTx2Gene) %>% 
  dcast(gene_id ~ sample, value.var = "count", fun.aggregate=sum)%>%
  magrittr::extract(,c("gene_id",samples$name)) %>%
  dplyr::filter(!is.na(gene_id))

# Preview
counts_g %>% as_tibble
```


## 7. Prepare DGEList

- We will store gene count estimates as DGEList 
objects for analysis later. 

- The DGEList for gene-level counts was created as follows: 

```{r}
counts_for_dge <- counts_g %>% 
  column_to_rownames("gene_id") %>%
  as.matrix

genes_for_dge <- data.frame(ensembl_gene_id = rownames(counts_for_dge)) %>%
  left_join(as.data.frame(genes) %>% 
              dplyr::select(gene_id, 
                            gene_name, 
                            gene_biotype, 
                            entrezid, 
                            description), 
            by = c("ensembl_gene_id"="gene_id"))

samples_for_dge <- samples %>% set_rownames(.$name)

dge <- DGEList(counts = counts_for_dge, 
               genes = genes_for_dge, 
               samples = samples_for_dge, 
               remove.zeros = TRUE) %>%  
  calcNormFactors("TMM")

dge
```



## 8. Initial PCA Visualisation

- We will use Principal Component Analysis to get an idea of the similarity 
of samples / libraries based on their gene  expression. 

- The PCA below indicates that **age** is the largest source of variation in 
the data (across **PC1**). 

- There is some separation of samples due to **genotype** and **hypoxia** 
across **PC2**. 

```{r}
pca_analysis1 <- prcomp(t(cpm(dge, log=TRUE)))

pca_geneExpression <- pca_analysis1$x %>% 
  magrittr::extract(, c("PC1", "PC2")) %>%
  as.data.frame %>%
  rownames_to_column("samples") %>%
  left_join((dge$samples %>% rownames_to_column("samples")), by="samples") %>%
  ggplot(aes(x=PC1, y = PC2, 
             colour = age, 
             shape = sex)) +
  geom_point(alpha = 0.7,size=3) +
  theme(aspect.ratio = 1) +
  # scale_colour_manual(values = c("red","cornflowerblue"), 
  #                     labels = c("Hypoxia","Normoxia")) +
    labs(x = "Principal Component 1 (9.7%)",
         y = "Principal Component 2 (7.1%)", 
         colour = "Age (months)", shape = "Sex") 

# summary(pca_analysis1)
# screeplot(pca_analysis1)
pca_geneExpression

export::graph2pdf(pca_geneExpression,
                  here("data", "datasets", "mouse", "GSE97113_new_pca.pdf"))
```



## 9. Filtering

- We chose the threshold of at least 1 cpm in at least 5 samples (number of 
samples in each condition) based on the following density plots. 

```{r}
keepTheseGenes <- (rowSums(cpm(dge) > 1) >= 5) 

A <- dge %>% 
  cpm(log = TRUE) %>% 
  melt %>% 
  dplyr::filter(is.finite(value)) %>% 
  ggplot(aes(x = value, colour = Var2)) +
  geom_density() + 
  guides(colour = FALSE) +
  ggtitle("A. Before filtering") +
  labs(x = "logCPM", y = "Density")

B <- dge %>% 
  cpm(log = TRUE) %>% 
  magrittr::extract(keepTheseGenes,) %>%
  melt %>% 
  dplyr::filter(is.finite(value)) %>% 
  ggplot(aes(x = value, colour = Var2)) +
  geom_density() + 
  guides(colour = FALSE) +
  ggtitle("B. After filtering")+
  labs(x = "logCPM", y = "Density")

grid.newpage()
vp1 <- viewport(x = 0, y = 0, width = 0.5, height = 1, just = c(0, 0))
vp2 <- viewport(x = 0.5, y = 0, width = 0.5, height = 1, just = c(0,0))
print(A, vp = vp1)
print(B, vp  = vp2)
```

- Using this threshold, we filtered out `r table(keepTheseGenes)[[1]]`
genes from the original `r length(keepTheseGenes)` genes, giving the 
remaining `r table(keepTheseGenes)[[2]]` to be used in the analysis. 

```{r}
dge_filtered <- dge[keepTheseGenes,,keep.lib.sizes = FALSE] 
```




## Export objects

- Gene-level and transcript-level counts

```{r}
counts_t %>% saveRDS(here("data", "datasets","mouse", 
                          "GSE97113", "counts_t.rds"))

counts_g %>% saveRDS(here("data", "datasets","mouse", 
                          "GSE97113", "counts_g.rds"))
```

- `DGEList` object

```{r eval=FALSE}
dge %>% saveRDS(here("data", "datasets","mouse", 
                          "GSE97113", "dge.rds"))
```

- Filtered `DGEList` objects

```{r eval=FALSE}
dge_filtered %>% saveRDS(here("data", "datasets","mouse", 
                          "GSE97113", "dge_filtered.rds"))
```

